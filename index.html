<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dear Dianne... â€” Sliding Puzzle</title>
  <!-- Google Font: Nunito -->
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #f9e9e7; /* soft pastel */
      --card: #fff; 
      --accent: #f8cdd0; 
      --text: #5b3b3b;
      --shadow: 0 6px 18px rgba(91,59,59,0.08);
      --radius: 14px;
      --gap: 10px;
      --n: 3; /* grid size */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:'Nunito',system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial;
      background: linear-gradient(180deg,var(--bg),#fff);
      color:var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:22px;
    }

    .app{
      width:100%;
      max-width:640px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:18px;
    }

    header{ text-align:center }
    header h1{ margin:0; font-size:1.4rem; font-weight:700; }
    header p{ margin:4px 0 0; font-size:0.95rem; color:#7a5b5b }

    /* puzzle wrapper keeps square layout */
    .puzzle-wrap{
      width: min(92vw,540px);
      max-width:100%;
      aspect-ratio: 1 / 1; /* keeps it square */
      position:relative;
      background: linear-gradient(180deg, rgba(255,255,255,0.7), rgba(255,255,255,0.55));
      border-radius: calc(var(--radius) + 6px);
      padding:18px;
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .grid{
      width:100%;
      height:100%;
      display:grid;
      grid-template-columns: repeat(var(--n), 1fr);
      gap: var(--gap);
      padding: var(--gap);
      background: transparent;
      border-radius: var(--radius);
      align-content:stretch;
    }

    .tile{
      position:relative;
      border-radius: var(--radius);
      background-color:var(--card);
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color: rgba(0,0,0,0.05);
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
      cursor:pointer;
      overflow:hidden;
      transition: transform 200ms ease;
    }
    .tile:active{ transform: scale(0.99) }

    .tile.empty{
      background: transparent;
      box-shadow: none;
      cursor: default;
    }

    /* image slicing: background-image assigned via JS */
    .tile .label{
      pointer-events:none;
      font-size:1.2rem;
    }

    .controls{
      display:flex;
      gap:10px;
      width:100%;
      justify-content:center;
    }
    button.btn{
      background:var(--accent);
      border:0;
      padding:10px 14px;
      border-radius:12px;
      font-weight:700;
      color:var(--text);
      box-shadow:0 4px 10px rgba(248,205,208,0.45);
      cursor:pointer;
    }

    /* modal */
    .overlay{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(180deg, rgba(91,59,59,0.06), rgba(255,255,255,0.02));
      padding:20px;
      z-index:40;
    }
    .modal{
      background: white;
      border-radius:16px;
      padding:18px 20px;
      max-width:420px;
      width:100%;
      box-shadow:0 20px 50px rgba(91,59,59,0.12);
      text-align:center;
    }
    .modal h2{ margin:0 0 8px; font-size:1.3rem }
    .modal p{ margin:0 0 14px; color:#6f4f4f }
    .modal .collect{
      display:inline-block;
      background:linear-gradient(180deg,#ff9fb0,#ff7b94);
      color:white;
      padding:10px 16px;
      border-radius:12px;
      text-decoration:none;
      font-weight:800;
      box-shadow:0 6px 18px rgba(255,123,148,0.25);
    }

    /* small footer tips */
    .notes{ font-size:0.85rem; color:#7a5b5b; text-align:center; max-width:640px }

    /* responsive tweaks */
    @media (max-width:420px){ header h1{ font-size:1.15rem } }
  </style>
</head>
<body>
  <div class="app">
    <!-- Change the name here -->
    <header>
      <h1>Dear Dianne...</h1>
      <p>Rebuild the picture to collect your surprise</p>
    </header>

    <div class="puzzle-wrap">
      <div class="grid" id="grid" aria-label="Sliding puzzle" role="application"></div>
    </div>

    <div class="controls">
      <button class="btn" id="shuffleBtn">Shuffle</button>
    </div>

    <div class="notes">
      <p>Tip: Tap tiles next to the empty space to slide them. Works on phones.</p>
    </div>
  </div>

  <!-- Win Modal (hidden until win) -->
  <div id="overlay" class="overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h2>Congratulations!</h2>
      <p>You completed the puzzle. Your prize is ready.</p>
   <!-- The anchor below triggers the download. Replace the href with your real prize.png file.
     If you place prize.png next to this HTML file, the relative path './prize.png' will work. -->
   <a id="collectBtn" class="collect" href="./prize.png" download="prize.png">Collect Your Prize</a>
    </div>
  </div>

  <script>
  /***** CONFIG & PLACEHOLDERS *****/
  // Replace the puzzleImageURL with your own square puzzle image (e.g., puzzle.jpg).
  // If you save the image next to this HTML file, use a relative path like './puzzle.jpg'.
  // Example: const puzzleImageURL = './puzzle.jpg';
  // Default below points to a local filename so you can replace it with your own file.
  const puzzleImageURL = './puzzle.jpg';
  // Replace the prize image URL in the collect <a> above (id="collectBtn") with your own prize.png

    // Grid size (3 for 3x3)
    const N = 3;

    /***** GAME STATE *****/
    let board = []; // array of length N*N, values 0..N*N-1, where 0 is the empty cell
    let emptyIndex = N*N - 1; // start with last slot empty
    let gameActive = true;

    const gridEl = document.getElementById('grid');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const overlay = document.getElementById('overlay');
    const collectBtn = document.getElementById('collectBtn');

    // Initialize resolved board (1..(N*N-1), 0)
    function solvedBoard(){
      const a = [];
      for(let i=1;i<=N*N-1;i++) a.push(i);
      a.push(0);
      return a;
    }

    // Render grid based on board array
    function render(){
      gridEl.innerHTML = '';
      const tileSizeStyle = '';
      board.forEach((v, idx) => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        // set size by letting grid and aspect ratio handle it

        if(v === 0){
          tile.classList.add('empty');
          tile.setAttribute('aria-hidden','true');
        } else {
          // Set background image slice for the tile using v's original position
          // Compute col,row in the source image for piece (v-1)
          const pieceIndex = v - 1;
          const col = pieceIndex % N;
          const row = Math.floor(pieceIndex / N);

          // Use background-size = 300% for 3x3 -> background-position 0%,50%,100% etc.
          tile.style.backgroundImage = `url(${puzzleImageURL})`;
          tile.style.backgroundSize = `${N * 100}% ${N * 100}%`;
          tile.style.backgroundPosition = `${(col / (N - 1)) * 100}% ${(row / (N - 1)) * 100}%`;
          tile.style.backgroundRepeat = 'no-repeat';

          // Optional light label (hidden visually if needed)
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = '';
          tile.appendChild(label);

          tile.setAttribute('role','button');
          tile.setAttribute('aria-label','Puzzle tile');
          tile.tabIndex = 0;

          tile.addEventListener('click', () => { tryMove(idx); });
          tile.addEventListener('keydown', (e) => {
            if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); tryMove(idx); }
          });
        }

        gridEl.appendChild(tile);
      });
    }

    function tryMove(index){
      if(!gameActive) return;
      if(isAdjacent(index, emptyIndex)){
        swap(index, emptyIndex);
        emptyIndex = index;
        render();
        checkWin();
      }
    }

    function swap(a,b){
      const t = board[a]; board[a] = board[b]; board[b] = t;
    }

    function isAdjacent(a,b){
      // adjacency in grid - up/down/left/right
      const ax = a % N, ay = Math.floor(a / N);
      const bx = b % N, by = Math.floor(b / N);
      const dx = Math.abs(ax - bx), dy = Math.abs(ay - by);
      return (dx + dy) === 1;
    }

    // Check if board is solved
    function checkWin(){
      const solved = solvedBoard();
      for(let i=0;i<board.length;i++) if(board[i] !== solved[i]) return false;
      // Win!
      gameActive = false;
      showWin();
      return true;
    }

    function showWin(){
      overlay.style.display = 'flex';
      // ensure collectBtn href points to configured prize image (developer replace comment above)
    }

    // Shuffle ensuring solvable and not already solved
    function shuffle(){
      const arr = [...board];
      // Fisher-Yates
      do {
        for(let i = arr.length - 1; i > 0; i--){
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      } while(!isSolvable(arr) || isSame(arr, solvedBoard()));
      board = arr;
      emptyIndex = board.indexOf(0);
      gameActive = true;
      overlay.style.display = 'none';
      render();
    }

    function reset(){
      board = solvedBoard();
      emptyIndex = board.indexOf(0);
      gameActive = true;
      overlay.style.display = 'none';
      render();
    }

    function isSame(a,b){
      if(a.length !== b.length) return false;
      for(let i=0;i<a.length;i++) if(a[i] !== b[i]) return false;
      return true;
    }

    // Solvability for odd grid width N: puzzle solvable if inversion count is even
    function isSolvable(arr){
      const flat = arr.filter(x => x !== 0);
      let inv = 0;
      for(let i=0;i<flat.length;i++){
        for(let j=i+1;j<flat.length;j++){
          if(flat[i] > flat[j]) inv++;
        }
      }
      if(N % 2 === 1){
        return inv % 2 === 0;
      } else {
        // For completeness if N even (not used here): check row of blank from bottom
        const blankRowFromBottom = N - Math.floor(arr.indexOf(0) / N);
        return (inv + blankRowFromBottom) % 2 === 0;
      }
    }

    /* Download helper: ensure collect button triggers a click; anchor has download attr set. 
       Note: Cross-origin downloads may be restricted by some browsers. For best results,
       host the prize image on the same origin or serve via your own server. */
    collectBtn.addEventListener('click', (e) => {
      // After clicking, close overlay (optional). We won't do more here.
      overlay.style.display = 'none';
    });

    // Initialize on load
    (function init(){
      board = solvedBoard();
      render();

      // Wire buttons
      shuffleBtn.addEventListener('click', shuffle);

      // Start shuffled
      shuffle();
    })();

    /***** Developer notes & tips (visible in file) *****/
    // 1) Replace `puzzleImageURL` with your own square image (e.g., '/images/puzzle.jpg').
    //    Best: 600x600 px or any square to keep slice math simple.
    // 2) Replace the href on the anchor with id="collectBtn" to your real 'prize.png'.
    //    Keep the attribute download="prize.png" so the file saves with that name.
    // 3) Hosting: For reliable download behavior, host this page on a web server
    //    (GitHub Pages, Netlify). Opening from file:// may still work in many browsers.

  </script>
</body>
</html>
